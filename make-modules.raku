use v6;

use experimental :rakuast;
use CSS::Specification::Compiler :&build-metadata;
use CSS::Module::CSS3::Metadata;
use NativeCall;

sub path(RakuAST::Package $p) {
    $p.name.parts>>.name.join: '/';
}

class Build {

    method build($where) {

        indir $where, {
            # inherit and subclass CSS3 properties
            my %props = $CSS::Module::CSS3::Metadata::property;

            for (<etc css3x-background-20120724.txt> => <CSS3 Backgrounds_and_Borders>,
                ) {
                my ($input-spec, $class-isa) = .kv;
                my @base-id = flat <CSS Module>, @$class-isa, <Spec>;
                my @grammar-id = @base-id.Slip, 'Grammar';
                my $scope := 'unit';
                my CSS::Specification::Compiler $compiler .= new;
                my $file = $input-spec.join: '/';
                my @defs = $compiler.load-defs: :$file;
                my %child-props = $compiler.child-props;
                my RakuAST::Package $grammar-ast = $compiler.build-grammar(@grammar-id, :$scope);
                "lib/{$grammar-ast.&path}.pm".IO.spurt: $grammar-ast.DEPARSE
                 .subst(/";\n;"/, ';', :g); # work-around for https://github.com/rakudo/rakudo/issues/5991

                my @actions-id = @base-id.Slip, 'Actions';
                my RakuAST::Package $actions-ast = $compiler.build-actions(@actions-id, :$scope);
                "lib/{$actions-ast.&path}.pm".IO.spurt: $actions-ast.DEPARSE;

                my @role-id = @base-id.Slip, 'Interface';
                my RakuAST::Package $role-ast = $compiler.build-role(@role-id, :$scope);
                "lib/{$role-ast.&path}.pm".IO.spurt: $role-ast.DEPARSE;
                my %meta = @defs.&build-metadata(:%child-props);
                %props ,= %meta;
                
                # &build-defaults is awkward here, maybe CSS::Properties should do this at run-time?
                my $grammar = (require ::("CSS::Drafts::CSS3"));
                my $actions = ::("CSS::Drafts::CSS3")::("Actions");
                %meta.&build-defaults(:$grammar, :$actions);
            }
            %props.&write-metadata;
        }
    }
}

sub build-defaults(%meta, :$grammar!, :$actions! is copy, ) {
    for %meta.kv -> $prop, %details {
        with %details<default> -> $default {
            unless $default ~~ Array {
                my $spec = "$prop:$default";
                try {
                    $actions .= new;
                    with $default.contains('agent'|'value of'|'nameless') ?? Nil !! $grammar.parse("$prop:$default", :$actions, :rule<declaration>) {
                        %details<default> = [$default, .ast<property><expr>]
                                                unless $actions.warnings;
                    }
                    else {
                        %details<default>:delete;
                    }
                    CATCH { default {
                                  warn "unable to parse {$spec.raku}: {.message}"
                              }
                          }
                }
            }
        }
    }
}


sub write-metadata(%props) {
    my $class-dir = $*SPEC.catdir(<lib CSS Drafts CSS3>);
    my $class-path = $*SPEC.catfile( $class-dir, 'Metadata.pm' );
    my $class-name = 'CSS::Drafts::CSS3::Metadata';
    say "Building $class-name";
    {
        my $*OUT = open $class-path, :w;
        say "#  -- DO NOT EDIT --";
        say "# generated by: $*PROGRAM-NAME {@*ARGS}".trim;
        say 'use NativeCall;';
        say 'use CSS::Module::Property;';
        say '';
        say "module $class-name \{";
        say "    BEGIN our \$property = {%props.item.raku};";
        # todo: BEGIN our \$index = ... ; ## Missing serialize REPR function for REPR
        say '    our enum prop-names <' ~ %props.keys.sort.join(' ') ~ '>;';
        say q:to<END>;
            our sub index {
                state $ //= do {
                    my $enums := prop-names.enums;
                    CArray[CSS::Module::Property].new: |$property.sort.map({CSS::Module::Property.new(:$enums, name => .key, |.value)});
                }
            }
        }
        END
        $*OUT.close;
    }
}

sub MAIN(Str $working-directory = '.' ) {
    Build.new.build($working-directory);
}

